const std = @import("std");
const fs = std.fs;
const io = std.io;

const clap = @import("clap");

const bytec_version = @import("version.zig").bytec_version; // dynamically generated via build.zig

const Lexer = @import("Lexer.zig");
const Generator = @import("Generator.zig");

pub fn main() !u8 {
    var dba = std.heap.DebugAllocator(.{}).init;
    defer {
        if (dba.deinit() == .leak)
            std.debug.print("WARNING: leaks were detected\n\n\n\n", .{});
    }

    const allocator = dba.allocator();

    const stdout_writer = io.getStdOut().writer();
    var outbw = io.bufferedWriter(stdout_writer);
    const stdout = outbw.writer();

    defer outbw.flush() catch {};

    const stderr_writer = io.getStdErr().writer();
    var errbw = io.bufferedWriter(stderr_writer);
    const stderr = errbw.writer();

    defer errbw.flush() catch {};

    const params = comptime clap.parseParamsComptime(
        \\-h, --help          Display this help and exit.
        \\-v, --version       Print the current Zonk version.
        \\-t, --tokens        Print the tokens generated by the lexer.
        \\-o, --output <str>  The name of the file to write to.
        \\<str>
        \\
    );

    var diag = clap.Diagnostic{};
    var res = clap.parse(clap.Help, &params, clap.parsers.default, .{
        .diagnostic = &diag,
        .allocator = allocator,
    }) catch |err| {
        diag.report(stderr_writer, err) catch {};
        return 1;
    };
    defer res.deinit();

    if (res.args.help != 0) {
        try clap.help(stdout_writer, clap.Help, &params, .{});
        return 0;
    }

    if (res.args.version != 0) {
        try stdout.print("Bytec version {s}\n", .{bytec_version});
        return 0;
    }

    if (res.positionals[0] == null) {
        try stderr.print("no input file\n", .{});
        return 1;
    }

    const input = res.positionals[0].?;
    const output = if (res.args.output) |o| o else "out.bin";

    const dir = std.fs.cwd();

    const maxSize = std.math.maxInt(usize);
    const data = dir.readFileAlloc(allocator, input, maxSize) catch |err| switch (err) {
        error.FileNotFound => {
            try stderr.print("file '{s}' does not exist\n", .{input});
            return 1;
        },
        else => return err,
    };
    defer allocator.free(data);

    var lexer = try Lexer.init(allocator, data);
    defer lexer.deinit();

    const tokens = lexer.lex() catch |err| {
        if (lexer.err_string.len > 0)
            try stderr.print("{s}\n", .{lexer.err_string});

        return err;
    };

    if (res.args.tokens != 0) {
        for (tokens) |t| {
            const str = try t.str(allocator);
            defer allocator.free(str);

            try stdout.print("{s}\n", .{str});
        }
    }

    var generator = try Generator.init(allocator, tokens);
    defer generator.deinit();

    const bytes = generator.parse() catch |err| {
        if (lexer.err_string.len > 0)
            try stderr.print("{s}\n", .{lexer.err_string});

        return err;
    };

    var f = try dir.createFile(output, .{});

    try f.writeAll(bytes);

    return 0;
}
